寫完這週的題目之後，有比較一下這次的寫法和第二期的解法，感覺超奇妙的！
最明顯的差異是，第二期的時候對內建函式很不熟，解題的時候很少用到內建函式，但是本週的學習目標之一就是要熟悉、使用內建函式呀！

## hw1：好多星星

看到題目說要回傳陣列，所以就用 `.push()` 寫了。寫完之後翻出第二期的解法：

```js
// MTR02 的寫法
function stars(n) {
  let starA = ['*'] 
  for (let i = 1; i < n; i++ ) {
		starA[i] = starA[i-1] + '*'
  } 
  return starA
}
```

意外發現這樣寫有個問題： `stars(0) //output:['*'] ` 就不對了（不過題目有說 `n(1<=n<=30)` 所以也不會錯）

## hw2：大小寫互換

一開始的想法和第二期一樣，都是先宣告一個變數存結果，再用迴圈把轉換的字放進去

```js
// MTR02 的寫法
function alphaSwap(str) {
  let ans = '';
  for (let i = 0 ; i<=str.length-1 ; i++ ){
    str[i] === str[i].toUpperCase() ? 
      ans += str[i].toLowerCase() : ans += str[i].toUpperCase()
	}
  return ans	
}
```

後來覺得一定還有其他寫法，不能都寫一樣的 XD 就生出用 `.replace()` 的解法。

## hw3：判斷質數

一開始的寫法是用 **因數數量** 判斷是否為質數，只有兩個因數（1 和 n）代表是質數，這樣可以知道因數數量或是列出有哪幾個因數，但缺點是不管 n 是多少，都要跑 n 圈才會有答案。

回顧第二期的寫法：

```js
function isPrime(n) {
  if(n === 1) {
    return false;
  }else{
    for (let i = 2; i < n; i++) {
      if (n % i === 0) {
        return false;
      } 
    }
  }
  return true
}
```

不紀錄因數數量、迴圈碰到可以整除的數字時就終止，不用每次都跑 n 圈。

只是碰到質數還是要跑 n-2 圈才判斷的出來，於是就開始想一定要跑 n-2 圈嗎？

想了一下因數好像是成對出現的，像 10/2 = 5，就可以知道 2 和 5 都是 10 的因數：`1,2,5,10`
所以是剖半！跑 n/2 圈就可以了！

於是把迴圈範圍改成這樣 `for (let i = 2; i <= n/2; i++) {...} `，跑了幾個測試都蠻正常的，試著解釋一下：

> n=7 原本要跑 i = 2,3,4,5,6 才知道答案。
> 只要跑 i = 2, 3（i <=3.5）就可以了，因為超過 3.5 的正整數乘以 2，都會比 7 大，不可能是 7 的因數！
>
> 或者可以說：
>
> 要任兩個小於 7 的正整數 相乘後等於 7，才是 7 的因數。
> 拿最小的 2 來跟其他數相乘，乘到 4 就超過 7 了，所以 5 和 6 都不可能。

感覺蠻合理的，但不合理的地方是「因數是成對出現的」這句話，像 9 = 3 * 3，因數 `1,3,9` 就不成對。
因為是平方根 -> 所以不會成對 -> 所以只要開根號就好了嗎？！

想到這已經有點混亂，只覺得剛剛想到的剖半跟開根號很像，一個是 n/2 的一半，一個是平方的那種一半（難以形容的一半），反正都試試看好了，真的可行再來想為什麼會可行 XD

所以把迴圈範圍改成這樣 `for (let i = 2; i <= Math.sqrt(n); i++) {...}`，結果似乎是可行，但不知道為什麼可行。

比較兩個方式，n = 11 時：

- 用 n/2  跑 4 圈（i = 2, 3, 4, 5）
- 用 Math.sqrt(n) 跑 2 圈（i = 2, 3）

為何不用跑 4 和 5 勒？照剛剛的解釋「拿最小的 2 來跟其他數相乘，乘到 6 就超過 11 了，所以 7 之後的都不可能」但 4 和 5 還是有可能呀，為何不用跑 4 和 5 勒？

最後決定直接上網查：（[來源：pjchender](https://pjchender.blogspot.com/2017/09/algorithm-sieve-of-eratosthenes.html)）

>假如一個數 N 是合數，它有一個因數 a, a × b = N 
>則 a、b 兩個數中必有一個大於或等於 √N，一個小於或等於 √N。 
>因此，只要小於或等於 √N 的數中（1除外）不能整除 N，則 N 一定是質數。 

大概理解，但還是很難詳細說明..
比較特別的是 看到 `a × b = N ` 這行，想到之前提到的 n/2 其實是 **加法** 的一半：

>0 + 7 = 7
>1 + 6 = 7
>2 + 5 = 7
>3 + 4 = 7
>3.5 + 3.5 = 7，n/2 剖半是 3.5

但質數是 **乘法** ，所以一半是用根號來界定的(?!)，所以才會有 a、b 和 √N 的大小關係

>1 * 7 = 7
>2.6 * 2.6 ≒ 7， √N 剖半是 2.6

>1 * 16=16
>2 *  8 = 16
>4 * 4 = 16 ， √N 剖半是 4

就是這樣..XD 數學這東西 只可意會不可言傳 rrrrrrr

## hw4：判斷迴文

秉持著學習目標，用內建函式完成這題！

```js
function isPalindromes(str){
  return str === str.split('').reverse().join('')
}
```

但在測試的時候出現大小寫問題的錯誤：`'abBA'` 算是迴文嗎？

- 從 **字面** 看「abBA」倒過來是「ABba」=> false
- 從 **讀音** 唸「誒逼逼誒」倒過來是「誒逼逼誒」=> true

按照題目的迴文定義：**正著唸倒著唸都一樣**。唸起來都是`誒逼逼誒` 應該要是 `true`

所以 全部都轉成大寫 再判斷內容：

```js
function isPalindromes(str){
  return str.toUpperCase() === str.toUpperCase().split('').reverse().join('')
}
```

（但是中文就無解了，「魯」和「滷」念起來也是一樣的 XD）

## hw5：大數加法

第二次寫這題，現在比較熟悉短路性質，所以在處理位數不一樣要補 0 的時候，就沒有用到之前用的` .padStart()`

中間卡比較久的部分是像這樣的狀況：`add('00909', '0099')`。

- 前面的 0 會影響位數的長短，位數又會影響到後面迴圈的次數。
- 輸出的結果是 `01008`，需要移除前面的 0 嗎？

不過感覺沒什麼影響，所以目前的寫法是維持現況，沒有特別處理前面的 0 。



第二個遇到的問題是判斷要不要進位的迴圈，判斷到最後一項如果要進位，要多一項，所以多寫了一個判斷，判斷是不是最後一位，如果要進位就用 `.push()` 新增一個位數。

中途還冒出一個很ㄎㄧㄤ的疑惑：「如果進位是 +2 怎辦？」想了一下才發現，加法的進位只可能進 1 啊！但是乘法好像就會有這個狀況了 XD 



挑戰題 , To be continued….